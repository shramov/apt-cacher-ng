<!-- DISABLED_SUGAR
            <h2>File Type Pattern Tracing</h2>
            <p>
            This section provides a simple tool useful to identify new file name patterns which might be needed to configuration in order to handle new file types correctly. Please provide your findings to apt-cacher-ng author if they might be useful for other users.
            <a name="trace"></a>
            Current value of pattern extensions:
            <br>
            <pre>SPfilePatternEx: ${cfg:SPfilePatternEx}
VfilePatternEx: ${cfg:VfilePatternEx}
PfilePatternEx: ${cfg:PfilePatternEx}</pre>
	    <form action="#trace" method="get">
               <span style="white-space:nowrap;">
                  Current mode:
                  <font style="display:${:/cfg:patrace/inline/none};white-space:nowrap;">
                     <font style="color:red;font-weight:bold;white-space:nowrap;">Active</font>
                     (watching download activity)
                  </font>
                  <font style="display:${:/cfg:patrace/none/inline};white-space:nowrap;">not tracing
                  </font>
               </span>
               <span>
		    <input type="submit" name="doTraceStart" value="Start Tracing" ${:/cfg:patrace/disabled/}>
                    <input type="submit" name="doTraceStop" value="Stop Tracing" ${:/cfg:patrace//disabled}>
                    <input type="submit" name="doTraceClear" value="Clear Trace Data">
                 </span>
                    <p>Currently collected file paths not covered by the configured patterns:
                    <input type="submit" name="doTraceRefresh${random}" value="Refresh">
                    <pre><br>${curPatTraceCol}</pre>
	    </form>
	    -->
	 <!-- DISABLED_SUGAR
         <h3>Log analysis</h3>
         <table border=0 cellpadding=2 cellspacing=1 bgcolor="black">
            <tr>
               <td class="coltitle" rowspan=3>Period</td>
               <td class="coltitle" colspan=8>Cache efficiency</td>
            </tr>
            <tr>
               <td class="coltitle"><span>&nbsp;</span></td>
               <td class="coltitle" colspan=3>Requests</td>
               <td class="coltitle"><span>&nbsp;</span></td>
               <td class="coltitle" colspan=3>Data</td>
            </tr>
            <tr bgcolor="white">
               <td class="coltitle"><span>&nbsp;</span></td>
               <td class="coltitle">Hits</td>
               <td class="coltitle">Misses</td>
               <td class="coltitle">Total</td>
               <td class="coltitle"><span>&nbsp;</span></td>
               <td class="coltitle">Hits</td>
               <td class="coltitle">Misses</td>
               <td class="coltitle">Total</td>
            
            </tr>
            ${statsRow}
         </table>
         <br>
         Note: data table is created based on the current log file. Deviation from real request count is possible due to previous log file optimization.
	 -->




// this shall detect endian switches and also different implementation of time_t. In future, maybe also encode a revision into byte 1
#define FORMAT_MAGIC uint64_t(1721u << 16 | sizeof(tExpReader::tExpEntry))

/*
 * Simple binary dump file parser
 * Expected format:
 * <MAGIC-FIELD:8>
 * <timestamp:N><len_folder:2><path><len_filename:2>
 * ...
 */
struct tExpReader
{
	struct tExpEntry
	{
		time_t exDate;
		string_view sDirPathRel;
		string_view sFileName;
	};

	tExpEntry last;
	filereader f;
	string_view raw;
	bool Open(string_view srcRel)
	{
		if (! f.OpenFile(SABSPATH(srcRel), true))
			return false;
		raw = f.getView();
		if (raw.size() < 8)
			return false;
		uint64_t magic;
		memcpy(&magic, raw.data(), sizeof(magic));
		if (magic != FORMAT_MAGIC)
			return false;
		raw.remove_prefix(sizeof(magic));
	}
	tExpEntry* Next()
	{
		uint16_t slen;
		if (raw.size() < sizeof(last.exDate) + sizeof(slen))
			return nullptr;
		memcpy(&last.exDate, raw.data(), sizeof(last.exDate));
		memcpy(&slen, raw.data() + sizeof(last.exDate), sizeof(slen));
		raw.remove_prefix(sizeof (last.exDate) + sizeof (slen));
		if (AC_UNLIKELY(!slen))
			return nullptr;
		last.sDirPathRel = string_view(raw.data(), slen);
		raw.remove_prefix(slen);
		if (AC_UNLIKELY(raw.length() < sizeof(slen) + 1))
			return nullptr;
		memcpy(&slen, raw.data(), sizeof(slen));
		if (AC_UNLIKELY(!slen))
			return nullptr;
		last.sFileName = string_view(raw.data() + sizeof(slen), slen);
		raw.remove_prefix(sizeof(slen) + slen);
		return &last;
	}
};


struct tBinSer
{
	char serbuf[21];
	string_view Ser(uint16_t val);
	string_view Ser(uint32_t val);
	string_view Ser(uint64_t val);
};

